	/* %W%  %G% */

	/*-------------------------------------------------------------
	|							      |
	|	PROGRAM:  ntscable                                    |
	|							      |
	|	MODULE:   %M%                                         |
	|							      |
	|	MACHINE:  Sun 3/60                                    |
	|							      |
	|	STARTED:  20-APR-89        BY:  J.C. Wathey           |
	|							      |
	|	REVISED:  %G%         BY:  JCW                   |
	|							      |
	|	STATUS:      incomplete or untested		      |
	|                    compiles; partly tested		      |
	|                 -> runs; revisions in progress	      |
	|                    runs; stable version		      |
	|							      |
	|       CONTAINS: routine read_eutectic() and related       |
	|                 private routines                            |
	|       COMPILE:                                              |
	|                                                             |
	|       (use makefile)                                        |
	|                                                             |
	-------------------------------------------------------------*/

/*--------------------------------------- HEADER FILES --------------*/
#include "tf.h"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <ctype.h>
#include <errno.h>
#include "sets.h"
#include "ntscable.h"		       /* global defs & declarations */

	/* definitions related to the ASCII file format used by
	the Neuron Tracing System */

	      /* These serve both as tokens for the point types and as
	      offsets for pointing to the corresponding substrings of 
	      point_type_names  (declared below). */

#define	MTO	0
#define	TTO	3
#define	BTO	6
#define	CP	9
#define	FS	12
#define	SB	15
#define	BP	18
#define	NE	21
#define	ES	24
#define	MAE	27
#define	TAE	30
#define	BAE	33
#define	SOS	36
#define	SCP	39
#define	SOE	42
#define	OS	45
#define	OCP	48
#define	OE	51
#define	DS	54
#define	DCP	57
#define	DE	60

			    /* field addresses within the text line */
#define POINT_TYPE_ADDR	8
#define POINT_TYPE_SIZE	3
#define X_ADDR		16
#define Y_ADDR		24
#define Z_ADDR		32
#define DIAM_ADDR	40


static char	point_type_names[] =
"MTOTTOBTO CP FS SB BP NE ESMAETAEBAESOSSCPSOE OSOCP OE DSDCP DE";

/*-------------------------------------------------------------------*/
int read_eutectic(fp, neuron_ptr, line_number)

	/* Reads morphological description of a neuron from an ASCII
	file generated by the Neuron Tracing System and stores this
	description in dynamic memory under the appropriate fields of
	*neuron_ptr.  Gives messages and returns TRUE if error;
	otherwise returns FALSE. */

    FILE      * fp; 
    NEURON    * neuron_ptr; 
    int		line_number;

{
				       /*----- functions called -----*/
    void	append_soma_outline_point(),
		push_branch();

				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int 	error,
		point_type,
		point_number = 0,
		num_soma_outline_points = 0,
		num_tree_points = 0,
		num_branches = 0, 
		first_soma_point = 0;

    char      * filename;

    char	line[BUFSIZ],
	      * type_ptr;

    double	x, y, z, diam,
		area,
		x_prev,
		y_prev,
		x_start,
		y_start;

    SOMA_POINT *soma_outline = (SOMA_POINT *) NULL;

    TREE_POINT *tree_ptr,
	       *neurite_ptr;

    SET		origin,
		continue_tree,
		continue_soma,
		continue_outline,
		continue_dots,
		valid_types;
	
				       /*----- start function -------*/

    neuron_ptr->source = EUTECTIC;

    filename = neuron_ptr->input_filename;
    						  /* initialize sets */
    clear_set(origin);
    set_plus_char(origin, (char) MTO);
    set_plus_char(origin, (char) SOS);
    set_plus_char(origin, (char) OS);
    set_plus_char(origin, (char) DS);
    set_plus_char(origin, (char) DCP);

    clear_set(continue_tree);
    set_plus_char(continue_tree, (char) BP);
    set_plus_char(continue_tree, (char) CP);
    set_plus_char(continue_tree, (char) NE);
    set_plus_char(continue_tree, (char) ES);
    set_plus_char(continue_tree, (char) TAE);
    set_plus_char(continue_tree, (char) BAE);
    set_plus_char(continue_tree, (char) MAE);
    set_plus_char(continue_tree, (char) FS);
    set_plus_char(continue_tree, (char) SB);

    clear_set(continue_soma);
    set_plus_char(continue_soma, (char) SCP);
    set_plus_char(continue_soma, (char) SOE);

    clear_set(continue_outline);
    set_plus_char(continue_outline, (char) OCP);
    set_plus_char(continue_outline, (char) OE);

    clear_set(continue_dots);
    set_plus_char(continue_dots, (char) DCP);
    set_plus_char(continue_dots, (char) DE);

    set_assign(valid_types, origin);

	/* Skip over leading comment and header lines in the .nts file.
	All such lines must begin with a non-digit char. */

    while( !(error = !fgets(line, BUFSIZ, fp)) 
	   && 
	   !(point_number=atoi(line)) )
	line_number++;

    if (error) {
	fprintf(stderr, 
	"read_neuron: error reading %s at line %d\n", 
	filename, line_number);
    	return(TRUE);
    }
    			/* main reading loop: one line per iteration */

    while ( !feof(fp) && !ferror(fp) && point_number ) {

	line_number++;

						 /* parse point type */
	for (type_ptr = point_type_names,
	     point_type = 0;

	     *type_ptr
	     &&
	     strncmp(type_ptr, 
		       line + POINT_TYPE_ADDR, 
			 POINT_TYPE_SIZE);

	     type_ptr   += POINT_TYPE_SIZE,
	     point_type += POINT_TYPE_SIZE);

/*	if (!in_set(valid_types, point_type)) { */
	if (FALSE) {
	    fprintf(stderr,
	    "%s: nts invalid point type %3.3s in line %d\n",
	    filename, line + POINT_TYPE_ADDR, line_number);
	    return(TRUE);
	}
				     /* get coordinates and diameter */

	x =    atof(line + X_ADDR);
	y =    atof(line + Y_ADDR);
	z =    atof(line + Z_ADDR);
	diam = atof(line + DIAM_ADDR);


	switch( point_type ) {

	    case MTO: {
		num_tree_points++;
		if (start_new_tree(neuron_ptr, 
				    point_number,
				      &tree_ptr, 
			 	       &neurite_ptr,
			  	        x,y,z,diam ))
		    return(TRUE);
        	set_assign( valid_types, continue_tree );
		break;
	    }

				       /*----- local  variables -----*/
	    case BP: {
		num_tree_points++;
		if (append_to_tree(point_number,
				   &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		push_branch(tree_ptr);
		break;
	    }

	    case FS:
	    case SB:
	    case CP: {
		num_tree_points++;
		if (append_to_tree(point_number,
				   &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		break;
	    }

	    case NE:
	    case ES:
	    case MAE:
	    case TAE:
	    case BAE: {
		num_branches++;
		num_tree_points++;
		if (append_to_tree(point_number,
				    &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		if( stack_is_empty() )
		    set_assign(valid_types, origin);
		else if (pop_branch(&tree_ptr))
		    return(TRUE);
		break;
	    }

	    case SOS: {
		x_prev = x_start = x;
		y_prev = y_start = y;
		area = 0;
		first_soma_point = point_number;
		num_soma_outline_points++;
		append_soma_outline_point( &soma_outline,
					   point_number,
					   x, y, z);
		set_assign(valid_types, continue_soma);
		break;
	    }

	    case SCP: {
		area += (x_prev * y) - (x * y_prev);
		x_prev = x;
		y_prev = y;
		num_soma_outline_points++;
		append_soma_outline_point( &soma_outline,
					   point_number,
					   x, y, z);
		break;
	    }

	    case SOE: {
		area += (x_prev * y)  - (x * y_prev)
		      + (x * y_start) - (x_start * y);
		area /= 2;
		area = fabs(area);
		num_soma_outline_points++;
		append_soma_outline_point( &soma_outline, 
					   point_number,
					   x, y, z);
		if ( neuron_ptr->soma_diam 
		     < 
		     (diam = 2 * sqrt(area/M_PI)) ) {
		    neuron_ptr->soma_outline_diam = diam;
		    neuron_ptr->num_soma_outline_points 
		              = num_soma_outline_points;
		    neuron_ptr->first_soma_point 
		              = first_soma_point;
		    neuron_ptr->last_soma_point = point_number;
		    free_soma_outline(&(neuron_ptr->soma_outline));
		    neuron_ptr->soma_outline = soma_outline;
		    soma_outline = (SOMA_POINT *) NULL;
		}
		else {
		    free_soma_outline(&soma_outline);
		}
		num_soma_outline_points = 0;
		set_assign(valid_types, origin);
		break;
	    }

	    case OS: {
		set_assign(valid_types, continue_outline);
		break;
	    }

	    case DS: {
		set_assign(valid_types, continue_dots);
		break;
	    }

	    case DCP:
	    case OCP: {
		break;
	    }

	    case DE:
	    case OE: {
		set_assign(valid_types, origin);
		break;
	    }

	}	/* end: switch point_type */

						    /* get next line */
	if (fgets(line, BUFSIZ, fp))
	    point_number = atoi(line);

    }	/* end main reading loop */

    neuron_ptr->num_branches = num_branches;
    neuron_ptr->num_tree_points = num_tree_points;

    return(error);

}



