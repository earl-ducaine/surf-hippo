;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: SURF; Base: 10 -*-

#|

====================================================================================================
			       The Surf-Hippo Neuron Simulator System
====================================================================================================

This code was written as part of the Surf-Hippo Project, originally at the Center for Biological
Information Processing, Department of Brain and Cognitive Sciences, Massachusetts Institute of
Technology, and currently at the Neurophysiology of Visual Compuation Laboratory, CNRS.
                                                                                 
Permission to use, copy, modify, and distribute this software and its documentation for any purpose
and without fee is hereby granted, provided that this software is cited in derived published work,
and the copyright notice appears in all copies and in supporting documentation. The Surf-Hippo
Project makes no representations about the suitability of this software for any purpose. It is
provided "as is" without express or implied warranty.
                                                                                 
If you are using this code or any part of Surf-Hippo, please contact surf-hippo@ai.mit.edu to be put
on the mailing list.
                                                                                 
Copyright (c) 1989 - 2003, Lyle J. Graham                                                                                              

|#


;;; SYS Source file: randoms.lisp
(in-package "SURF-HIPPO")

;; some stuff pertaining to random variables and processes.

(defun get-uniform-xy-variants (&optional (number-of-samples 1))
  "Return a list with NUMBER-OF-SAMPLES [default 1] lists of single float pairs, each of which is a uniform variant over 0.0 and
1.0."
  (loop for x fixnum from 1 to number-of-samples  collect (list (random 1.0) (random 1.0))))



(proclaim '(inline poisson-interval))
;; Compare with EXPONENTIAL-RANDOM-NUMBER in roylance-clmath/statis.lisp
(defun poisson-interval (lambda)
  "Returns an time interval from a poisson distribution with rate LAMBDA [single float]."
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0))
	   (single-float lambda))
  (unless (> lambda 0.0) (sim-error (format nil "POISSON-INTERVAL called with non-positive LAMBDA ~A" lambda)))
  ;; Loop until we get a non-zero random, assuming that RANDOM can return 0. Is this true?
  (do ((val (random 1.0) (random 1.0)))
      ((> val 0.0) (* (- (the sf (log val))) (/ 1 lambda)))))

(proclaim '(inline poisson-events))
(defun poisson-events (lambda start stop &optional (min-interval-value 0.0))
  "Returns a list of times generated by a Poisson process with rate constant LAMBDA [1/ms], starting
at START and ending with STOP [ms]. Poisson intervals are taken at a minimum value of
MIN-INTERVAL-VALUE [ms]."
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0)))
  (let ((lambda (s-flt lambda))
	(start (s-flt start))
	(stop (s-flt stop))
	(min-interval-value (s-flt min-interval-value)))
    (declare (single-float lambda start stop))
    (if (<= lambda 0.0)
	'()
	(let (out)
	  (do ((x start (+ x (let ((interval (the sf (poisson-interval lambda))))
			       (if (> min-interval-value interval) min-interval-value interval)))))
	      ((> x stop))
	    (declare (single-float x))
	    (when (> stop x start) (push (the sf x) out)))
	  (reverse out)))))

(defun modulated-poisson-events (LAMBDA-SPEC start stop &key (step 1.0) (time-offset 0.0) (min-interval-value 0.0) (lambda-coefficient 1.0))
  "Returns a list of event times generated by a Poisson process with a modulated rate constant lambda over a total interval given
by START and STOP [ms]. Calculation of lambda at any given time depends on LAMBDA-SPEC. When LAMBDA-SPEC is a function, lambda is
given by a funcall of LAMBDA-SPEC with the time as the argument \(this function should take a single numeric argument and return a
single-float\). When LAMBDA-SPEC is a sequence lambda is the interpolated value of LAMBDA-SPEC appropriate for the current
time. Finally, if LAMBDA-SPEC is a number this gives directly the constant value of lambda. In all cases, the evaluation of
LAMBDA-SPEC is taken to be in 1/ms.  When LAMBDA-SPEC is a function, STEP [ms] should be a value for which the function is
relatively constant. When LAMBDA-SPEC is a sequence, then STEP is the time base. If LAMBDA-SPEC is a number, then the list of
events is generated by the function POISSON-EVENTS, with the START and STOP arguments adjusted by the value of TIME-OFFSET [ms,
default 0.0]. Otherwise, the events are generated by repeated calls to POISSON-INTERVAL, with the initial time given by START, and
until time reaches STOP. At every time increment if POISSON-INTERVAL gives a value greater than STEP, then the time is incremented
by STEP and the process repeated. If the returned poisson interval is less than STEP, then the time is incremented by the
interval, and this value is pushed onto the result list. All times in the returned list are adjusted by the addition of
TIME-OFFSET [ms].  Poisson intervals are taken at a minimum value of MIN-INTERVAL-VALUE [ms]. All numeric arguments must be single
floats."
;  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0)))
  (let ((start (s-flt start))
	(stop (s-flt stop))
	(step (s-flt step))
	(time-offset (s-flt time-offset))
	(min-interval-value (s-flt min-interval-value))
	(lambda-coefficient (s-flt lambda-coefficient))

	(array-length 0.0)
	out
	forced-step)
    (declare (single-float array-length start stop step time-offset min-interval-value lambda-coefficient))
    (typecase LAMBDA-SPEC
      ((or cons array)
       (setq LAMBDA-SPEC (s-flt-array LAMBDA-SPEC))
       (setq array-length (s-flt (length (the vec-flt lambda-spec))))))
    (if (numberp LAMBDA-SPEC)
      (poisson-events (* lambda-coefficient (s-flt lambda-spec))
		      (+ time-offset start)
		      (+ time-offset stop)
		      min-interval-value)
      (do ((x start
	      (+ x
		 (let* ((index (the sf (/ x step)))
			(lambda (the sf (* lambda-coefficient
					   (the sf
					     (typecase LAMBDA-SPEC
					       (function (funcall LAMBDA-SPEC x))
					       (t (if (>= index array-length)
						    0.0
						    (generic-interpolated-array-value LAMBDA-SPEC index))))))))
			(interval (when (> lambda 0.0) (poisson-interval lambda))))
		   (declare (single-float index))
		   (cond ((or (not (numberp interval)) (> (the sf interval) step))
			  (setq forced-step t)
			  step)
			 (t (setq forced-step nil)
			    (if (> MIN-INTERVAL-VALUE (the sf interval)) MIN-INTERVAL-VALUE (the sf INTERVAL))))))))
	  ((> x stop) (reverse out))
	(declare (single-float x))
	(when (and (not forced-step) (> stop x start)) (push (+ time-offset x) out))))))


;; Returns a single-float.
(proclaim '(inline rate-exponential))
(defun rate-exponential (time start end tau coeff)
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0))
	   (single-float time start end tau coeff))
  (cond ((< time start) 0.0)
	((< time end) (/ coeff (exp (/ (- start time) tau))))
	(t 0.0)))


;; Returns a list of events from a poisson process, starting from 0 to STOP, whose time constant TAU
;; is a function of the time relative to the start time. Similiar to MODULATED-POISSON-EVENTS,
;; except that in this case the modulating function is explicit (exponential).
(defun exponential-modulated-poisson-events (start stop step tau coeff)
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0))
	   (single-float start stop tau coeff step))
  (let (out forced-step)
    (do ((x start (+ x (the sf (let ((interval (poisson-interval (/ 1 (rate-exponential x start stop tau coeff)))))
				 (cond ((or (not interval) (> (the sf interval) step))
					(setq forced-step t)
					step)
				       (t (setq forced-step nil)
					  interval)))))))
	((> x stop))
      (declare (single-float x))
      (when (and (not forced-step) (> stop x start)) (push x out)))
    (if out (reverse out) '())))

#|
(defun exponential-modulated-poisson-events (start stop step tau coeff)
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0))
	   (single-float start stop tau coeff step))
  (let (out forced-step)
    (loop for time from start to stop by step
	  when (< (random 1.0)
		  (* step (rate-exponential time start stop tau coeff))))))
|#


(defun exponential-pdf (lambda)
  "Returns a random sample (single float) out of an exponential PDF with characteristic decay constant
LAMBDA (must be a single float)."
  (declare (optimize (safety 0) (speed 3) (space 1))
	   (single-float lambda))
  (* (- lambda) (the sf (log (the sf (- 1 (random 1.0)))))))



(defun shuffled-indices (length)
  "Return of list of integers ranging from 0 to (LENGTH - 1), in random order."
  (declare (optimize (safety 0) (speed 3) (space 1)))
  (let* ((length (round length))
	 (indices (the cons (list-of-nums length 0 1)))
	 choice-index)
    (loop repeat (the fn length)
	  for indice-length fixnum downfrom (length indices)
	  do (setq choice-index (if (= 1 indice-length) 0 (round (the sf (random (float (1- indice-length)))))))
	  collect (nth choice-index indices) into out
	  do (setq indices (remove (car (last out)) indices))
	  finally (return out))))
    
;; should recode this using an array....
(defun shuffled-list (list)
  "Return of scrambled version of LIST."
  (loop for index in (SHUFFLED-INDICES (length list)) collect (nth index list)))


   
  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;     REFERENCE-RANDOM-STATE Functions
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun save-reference-random-state (&optional filename)
  (let ((filename (cond (filename filename)
			((probe-file (concatenate-strings *Surf-user-dir* "random-state"))
			 (concatenate-strings *Surf-user-dir* "random-state"))
			(t (concatenate-strings *Surf-home* "lib/random-state")))))
    (with-open-stream
     (stream (open filename :direction :output :if-exists :supersede))
     (print (make-random-state t) stream)
     (format t "Random state written to ~A" (ext:unix-namestring stream))
     nil)))

(defun get-reference-random-state (&optional filename)
  (when (and filename (not (probe-file filename)))
    (sim-error (format nil "Looking for a random state in a bogus file ~A" filename)))
  (let ((filename (cond (filename filename)
			((probe-file (concatenate-strings *Surf-user-dir* "random-state"))
			 (concatenate-strings *Surf-user-dir* "random-state"))
			(t (concatenate-strings *Surf-home* "lib/random-state")))))
    (with-open-stream (stream (open filename :direction :input))
		      (setq *random-state* (read stream)) nil)
    *random-state*))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun random-phase-sequence-half-mag-and-phase-no-dc (delta-hz inner-duration low-cutoff high-cutoff mag-function max-freq)
  (declare (optimize (safety 0) (speed 3) (space 0))
	   (single-float max-freq delta-hz low-cutoff high-cutoff))
  (flet ((get-random-phase (freq low-cutoff high-cutoff)
			   (if (not (>= high-cutoff freq low-cutoff)) 0.0 (- (random (* 2 pi-single)) pi-single)))
	 (get-mag (mag-function freq low-cutoff high-cutoff)
		  (if (not (>= high-cutoff freq low-cutoff)) 0.0 (case mag-function
								   (:flat 1.0)
								   (:1/f (/ 1 freq))
								   (:1/F-SQUARED (/ 1 (* freq freq)))))))
    (let ((max-freq-mag (get-mag mag-function max-freq low-cutoff high-cutoff))
	  (max-freq-phase (get-random-phase max-freq low-cutoff high-cutoff)))
      (loop for freq single-float from delta-hz by delta-hz
	    for count fixnum from 1 to (1- (the fn (/ (the fn inner-duration) 2)))
	    collect (get-mag mag-function freq low-cutoff high-cutoff) into half-of-mag-no-dc
	    collect (get-random-phase freq low-cutoff high-cutoff) into half-of-phase-no-dc
	    finally (return (values
			     half-of-mag-no-dc
			     half-of-phase-no-dc
			     max-freq-mag
			     max-freq-phase))))))

#|
;; a noisy scope
(defun foo ()
  (let ((*preserve-plot-layout* t))
    (dotimes (i 30 )
      (RANDOM-PHASE-SEQUENCE 1000 :plot-result t :mag-function :1/f
					; :flat
			     :low-cutoff 10 :high-cutoff 200 :plot-mag-phase nil
			     :delta-t 0.5
			     :VERBOSE-PLOT-TITLES nil))))
|#

(defun random-phase-sequence-old (duration ; ms
				  &key (low-cutoff 0) high-cutoff ; hz
				  (delta-t 1.0) ; ms
				  (mag-function :FLAT) ; Also :1/F, :1/F-SQUARED
				  (verbose-plot-titles t)
				  (rms 1) (rms-on-infinite-sequence t) (ac-coupled t) plot-mag-phase plot-result plot-dft-sequences return-list)
  (declare (optimize (safety 2) (speed 3) (space 0)))
  (let* ((delta-t (s-flt delta-t))
	 (output-time-steps (round (/ duration delta-t)))
	 (inner-duration (round-up-to-power-of-2 (/ duration delta-t)))
	 (max-freq (* 0.5 (/ 1000.0 delta-t))) ; hz
	 (high-cutoff (s-flt (or high-cutoff max-freq)))
	 (low-cutoff (s-flt low-cutoff))
	 (delta-hz (/ (* 2 max-freq) inner-duration)))
    (declare (single-float delta-hz delta-t max-freq high-cutoff low-cutoff)
	     (fixnum output-time-steps inner-duration))
    (multiple-value-bind (half-of-mag-no-dc half-of-phase-no-dc max-freq-mag max-freq-phase)
	(random-phase-sequence-half-mag-and-phase-no-dc delta-hz inner-duration low-cutoff high-cutoff mag-function max-freq)
      (multiple-value-bind (half-of-real-no-dc half-of-imag-no-dc)
	  (real-and-imaginary-from-mag-and-phase half-of-mag-no-dc half-of-phase-no-dc)
	(let* ((dc-mag (if (or ac-coupled (> low-cutoff 0)) 0.0 1.0)) ; dc-phase implicitely is 0.0
	       (real-at-f_max (real-from-mag-phase max-freq-mag max-freq-phase))
	       (imag-at-f_max (imag-from-mag-phase max-freq-mag max-freq-phase))
	       (real-input (CONCATENATE-TO-SF-ARRAY dc-mag half-of-real-no-dc real-at-f_max (reverse half-of-real-no-dc))) ; dc-real = dc-mag
	       (imag-input (CONCATENATE-TO-SF-ARRAY 0.0 half-of-imag-no-dc imag-at-f_max (negate-single-float (reverse half-of-imag-no-dc))))) ; dc-imag = 0
	  (multiple-value-bind (real-output imag-output)
	      (dft-reverse-complete real-input imag-input delta-hz :plot plot-dft-sequences :return-values t :return-values-as-lists nil :output :real-imag)
	    (declare (ignore imag-output))
	    (let* ((ss-freq-mag (+ (square dc-mag) (* 2 (ss half-of-mag-no-dc)) (* max-freq-mag max-freq-mag))) ; Sum of freq_mag^2
		   (rms-infinite-output (/ (the sf (sqrt ss-freq-mag)) inner-duration)) ; This derives from Parseval's theorem.
		   (actual-output (loop for index fixnum from 0 to (1- output-time-steps) collect (aref real-output index)))
		   (rms-actual-output (rms actual-output))
		   (gain (if (zerop rms-actual-output) 1.0 (/ rms (if RMS-ON-INFINITE-SEQUENCE rms-infinite-output rms-actual-output)))))
	      (declare (single-float rms-actual-output rms-infinite-output ss-freq-mag gain))
	      (unless (= gain 1) (setq actual-output (SCALE-FLOAT-list gain actual-output))) ; Adjust output amplitude if necessary.
	      (random-phase-sequence-plot-routines VERBOSE-PLOT-TITLES plot-result plot-mag-phase actual-output mag-function gain
						   ac-coupled low-cutoff high-cutoff delta-t duration delta-hz max-freq
						   half-of-mag-no-dc max-freq-mag half-of-phase-no-dc max-freq-phase)
	      (when return-list actual-output))))))))


(defun random-phase-sequence-plot-routines (VERBOSE-PLOT-TITLES
					    plot-result plot-mag-phase actual-output mag-function gain ac-coupled low-cutoff high-cutoff
					    delta-t duration delta-hz max-freq half-of-mag-no-dc max-freq-mag half-of-phase-no-dc max-freq-phase)
  (flet ((plot-title (mag-function ac-coupled low-cutoff high-cutoff max-freq &optional extra)
		     (if (not VERBOSE-PLOT-TITLES)
		       (format nil "Random Phase Process~A" (if extra (format nil " ~A" extra) ""))
		       (format nil "Random Phase ~A Mag Process: ~A~A"
			       (STRING-CAPITALIZE (format nil "~A" mag-function))
			       (cond ((and (not ac-coupled) (= low-cutoff 0) (>= high-cutoff max-freq)) "Wideband")
				     ((and ac-coupled (= low-cutoff 0) (>= high-cutoff max-freq)) "Wideband, no DC")
				     ((>= high-cutoff max-freq) (format nil "HPF ~a hz" low-cutoff))
				     (t (format nil "HPF ~a hz, LPF ~a hz" low-cutoff high-cutoff)))
			       (if extra (format nil " ~A" extra) "")))))
    (when plot-mag-phase
      (let ((mag-input (scale-float-list
			gain
			(concatenate 'list `(,(if (or ac-coupled (> low-cutoff 0)) 0.0 1.0)) ; dc mag
				     half-of-mag-no-dc (list max-freq-mag) (reverse half-of-mag-no-dc))))
	    (phase-input (concatenate 'list '(0.0) half-of-phase-no-dc (list max-freq-phase) (negate-single-float (reverse half-of-phase-no-dc)))))
	(plot-timed-data (fold-wave mag-input) nil delta-hz :delta-t-start (round (- max-freq))
			 :x-min (- max-freq) :x-max max-freq :x-origin (- max-freq) :y-origin 0 :default-number-of-x-incs 10
			 :y-label "Mag" :x-label "Hz" :x-label-horizontal-position :right :x-are-fns t
			 :title (plot-title mag-function ac-coupled low-cutoff high-cutoff max-freq "Mag Input"))
	(plot-timed-data (fold-wave phase-input) nil delta-hz :delta-t-start (round (- max-freq))
			 :x-min (- max-freq) :x-max max-freq :y-max pi :y-min (- pi) :x-origin (- max-freq) :y-origin (- pi) :y-axis-root 0
			 :default-number-of-x-incs 10 :y-label "Phase" :x-label "Hz" :x-label-horizontal-position :right :x-are-fns t
			 :title (plot-title mag-function ac-coupled low-cutoff high-cutoff max-freq "Phase Input"))))
    (when plot-result
      (plot-timed-data actual-output nil delta-t :x-are-fns t :x-label "ms" :x-max duration :x-label-horizontal-position :right
		       :title (plot-title mag-function ac-coupled low-cutoff high-cutoff max-freq)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Random deviate generator after Press etal (Transformation method)


(defun exponential-random-number ()
  "Returns a double-float random number taken from an exponential distribution with lambda of 1."
  (do ((random (random 1.0d0) (random 1.0d0)))
      ((> random 0)
       (- (log random)))))


;; See also NORMAL-RANDOM-NUMBER in roylance-clmath/statis.lisp, using Ratio of Uniform Deviates Method. This one here should be
;; much faster, since it is not iterative.

(defvar *erf-array*)
(defvar *erf-array-argument*)

;; Fill the *erf-XX* arrays.
(let ((step 0.0010d0)
      (max 7.0d0))
  (loop for x double-float from (- max) to max by step
	collect (* 0.5 (+ 1 (user::erf x))) into erf
	collect x into erf-x
	finally
	(setq *erf-array-argument* (d-flt-array erf-x)
	      *erf-array* (d-flt-array erf))))			   

(defun normal-random-number ()
  "Return a double-float random number taken from a normal distribution with mean of 0 and variance of 0.5."
  (aref *erf-array-argument* (array-search-double (random 1.0d0) *erf-array*)))


#|
(plot-histogram-list (loop for x from 1 to 10000 collect (aref *erf-array-argument* (array-search (random 1.0d0) *erf-array*)))
		     :bin-width 0.025 :bins 240 :x-min -3 :x-max 3
		     :x-axis-tick-skip 9)

(plot-histogram-list (loop for x from 1 to 500 collect (aref *erf-array-argument* (simple-array-search (random 1.0d0) *erf-array*)))
		     :bin-width 0.025 :bins 240 :x-min -3 :x-max 3
		     :x-axis-tick-skip 9)

(plot-timed-data
 (loop for x from 0 to 1.0 by 0.001 collect (aref *erf-array-argument* (array-search x *erf-array*))))

(plot-timed-data
 (loop for x from 0 to 1.0 by 0.001 collect (aref *erf-array* (array-search x *erf-array*))))

(let ((step 0.010))
  (loop for x from -4.0 to 4.0 by step
	
	collect x into time
	collect (* 0.5 (+ 1 (user::erf x))) into erf
	collect (gaussian x 0.0 0.50) into gauss
	collect  (+ (or (car (last gauss-int)) 0) (* step (gaussian  x 0.0 0.50))) into gauss-int
	finally   (plot-timed-data (list	ERF gauss-int
						gauss)

				   '(erf gauss-int gauss) time)))

|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Code written by Nicolas Gazeres.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; RANDOM-NTH
;;; - Returns an randomly chosen element from a list

(proclaim '(inline SF-RANDOM-NOT-ZERO))
(defun SF-RANDOM-NOT-ZERO (x)
  "Returns a random value, of type single-float, between 0.0 and x. The returned value is guaranteed to be different from 0.0 and x.
Argument x must be of type single-float." 
  (declare (optimize (safety 0) (speed 3) (space 0) (compilation-speed 0))
	   (single-float x))
  (do ((y (kernel:%random-single-float (ext:truly-the sf x) *random-state*)
	  (kernel:%random-single-float (ext:truly-the sf x) *random-state*)))
      ((not (zerop y)) y)
    (declare (single-float y))))

(proclaim '(inline DF-RANDOM-NOT-ZERO))
(defun DF-RANDOM-NOT-ZERO (x)
  "Returns a random value, of type double-float, between 0.0 and x. The returned value is guaranteed to be different from 0.0 and x.
Argument x must be of type double-float."
  (declare (optimize (speed 3) (safety 0) (space 1) (compilation-speed 0))
	   (double-float x))
  (do ((y (kernel:%random-double-float (ext:truly-the df x) *random-state*)
	  (kernel:%random-double-float (ext:truly-the df x) *random-state*)))
      ((not (zerop y)) y)
    (declare (double-float y))))

(defun RANDOM-NOT-ZERO (x)
  "Returns a random value, of type double-float or single-float depending on x, between 0.0 and x. The returned value
is guaranteed to be different from 0.0 and x. The properly optimized function is called."
  (declare (optimize (speed 3) (safety 0) (space 1) (compilation-speed 0))
	   (type (or double-float single-float) x))
  (typecase x
    (single-float (SF-RANDOM-NOT-ZERO (ext:truly-the sf x)))
    (double-float (DF-RANDOM-NOT-ZERO (ext:truly-the df x)))))



#|
(defun RANDOM-NTH (list)
  (when list (nth (random (length list)) list)))
|#

(defun RANDOM-NTH (liste &optional (total 1))
  "Returns TOTAL [default 1] elements picked randomly from a list."
  (declare (optimize (safety 1) (speed 3) (space 0))
	   (type (or NULL cons) liste))
  (when liste
    (let ((total (round total)))
      (if (> total (length liste))
	  (sim-error (format nil "RANDOM-NTH: TOTAL of ~A is more than the list length!" total))
	  (loop until (= (length out) total)
		with temp
		do (setq temp (nth (random (the (INTEGER 1 524287) (length liste))) liste))
		unless (member temp out)
		collect temp into out
		finally (return (atomize-list out)))))))


;;;  RANDOM-SUBSEQ
;;; - Returns a randomly chosen sub-list in given list
;;; - Sub-list is of length 'number'
;;; - If number is greater than the length of the original list, then
;;;   returns the list itself
;;; - Only drawback : makes a temporary copy of original list onto which
;;;   it makes destructive operations.

(defun RANDOM-SUBSEQ (liste number)
  (declare (optimize (safety 0) (speed 3) (space 0) (debug 3))
	   (fixnum number) (cons liste))
  (let  ((longueur (length liste)))
    (declare (fixnum longueur))
    (if (>= number longueur)
	(copy-list liste)
	;; Cas general :  il faut extraire aleatoirement
	(progn
	  (let ((provlist (copy-list liste)))
	    (declare (cons provlist))
	    (loop for k of-type fixnum below number 
		  for l of-type fixnum downfrom longueur
		  collect (let ((elemt (nth (random (the (integer 1 524287) l)) provlist)))
			    (setq provlist (delete elemt provlist :test 'equal))
			    elemt)))))))


;;; RANDOM-SUBSEQ
;;; --------------
;;; - retourne une sous-liste choisie aleatoirement dans la liste fournie, de longueur number
;;; - si number est plus grand que la longueur de la liste, on retourne la liste elle-meme.
;;; - effectue une copie temporaire sur laquelle faire les operations DESTRUCTRICES...

(defun RANDOM-SUBSEQ (liste number)
  "Returns a random sub-list of a list. Non-destructive."
  (declare (optimize (safety 1) (speed 3) (space 0) (debug 3))
	   (fixnum number))  ; (or cons null liste)
  (when liste
    (let  ((longueur (length (the (or cons null) liste))))
      (declare (fixnum longueur))
      (if (>= number longueur)
	  (copy-list liste)
	  ;; Cas general :  il faut extraire aleatoirement
	  (progn
	    (let ((provlist (copy-list liste)))
	      (declare (cons provlist))
	      (loop for k of-type fixnum below number 
		    for l of-type fixnum downfrom longueur
		    collect (let ((elemt (nth (random (the (integer 1 524287) l)) provlist)))
			      (setq provlist (delete elemt provlist :test 'equal))
			      elemt))))))))

;;; non-debuggee !!!!
(defun RANDOM-SUB-ARRAY (array nb-avail nb-pick)
  (declare (optimize (safety 1) (speed 3) (space 0))
           (fixnum nb-pick nb-avail))
  (if (< nb-pick nb-avail)
      (loop for k of-type fixnum below nb-pick 
            for l of-type fixnum downfrom nb-avail
            do (let* ((index (random (the (integer 1 524287) l)))
                      (prov-synapse (aref (the (simple-array cell (*)) array) (+ k index))))
                 (setf (aref (the (simple-array * (*)) array) (+ k index))
                       (aref (the (simple-array * (*)) array) k))
                 (setf (aref (the (simple-array * (*)) array) k)
                       prov-synapse))
            finally (return nb-pick))))






   
