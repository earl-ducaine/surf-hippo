	/* %W%  %G% */

	/*-------------------------------------------------------------
	|							      |
	|	PROGRAM:  ntscable                                    |
	|							      |
	|	MODULE:   %M%                                         |
	|							      |
	|	MACHINE:  Sun 3/60                                    |
	|							      |
	|	STARTED:  20-JUL-90        BY:  J.C. Wathey           |
	|							      |
	|	REVISED:  %G%         BY:  JCW                   |
	|							      |
	|	STATUS:      incomplete or untested		      |
	|                    compiles; partly tested		      |
	|                 -> runs; revisions in progress	      |
	|                    runs; stable version		      |
	|							      |
	|       CONTAINS: routine read_douglas_2d() and related       |
	|		  private routines                            |
	|                                                             |
	|       COMPILE:                                              |
	|                                                             |
	|       (use makefile)                                        |
	|                                                             |
	-------------------------------------------------------------*/

/*--------------------------------------- HEADER FILES --------------*/
#include "tf.h"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <ctype.h>
#include <errno.h>
#include "sets.h"
#include "ntscable.h"		       /* global defs & declarations */

	/* definitions related to the ASCII file format used by
	Rodney Douglas' neuron digitizing system; 2D syntax */

	      /* These serve both as tokens for the point types and as
	      offsets for pointing to the corresponding substrings of 
	      point_type_names  (declared below). */

#define	SOM	0
#define	BP 	3
#define	NE 	6
#define	MAE	9
#define	TAE	12
#define	BAE	15

			    /* field addresses within the text line */
#define POINT_TYPE_ADDR	50
#define POINT_TYPE_SIZE	3
#define LENGTH_ADDR	31
#define DIAM_ADDR	40

						  /* microns per cm */
#define SCALE 10000.0

				/* Determines vertical spacing between 
				branches in 2D diagram drawn by NEURON
				simulator from info supplied via calls
				to pt3Dadd().  A value of 1.0 may 
				cause some adjacent branches to touch.
				Larger values increase the separation.
				*/
#define BRANCH_SPACING	1.2

static char	point_type_names[] = "sombp ne maetaebae";
static char	end_of_file[]      = "end 1 1 1 1 ";

/*-------------------------------------------------------------------*/
int read_douglas_2d(fp, neuron_ptr, line_number)

	/* Reads morphological description of a neuron from an ASCII
	file generated by Rodney Douglas' neuron digitizing system 
	(2D syntax) and stores this description in dynamic memory 
	under the appropriate fields of *neuron_ptr.  Gives messages 
	and returns TRUE if error; otherwise returns FALSE. */

    FILE      * fp; 
    NEURON    * neuron_ptr; 
    int		line_number;
{
				       /*----- functions called -----*/
    char      * strchr();
    void 	calculate_3D_coordinates(),
		push_branch();
    int		stack_is_empty(),
		pop_branch();

				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int 	error,
		next_branch_is_rooted_at_soma = TRUE,
		point_type,
		num_tree_points = 0,
		num_branches = 0,
		point_number = 0;

    char      * filename,
	      * label;

    char	line[BUFSIZ],
	      * type_ptr;


    double	length,
		diam;

    TREE_POINT *tree_ptr,
	       *neurite_ptr;

    SET		origin,
		continue_tree,
		valid_types;
	
				       /*----- start function -------*/

    neuron_ptr->source = DOUGLAS_2D;
    neuron_ptr->average_outline_z_coords = FALSE;

    filename = neuron_ptr->input_filename;
    						  /* initialize sets */
    clear_set(origin);
    set_plus_char(origin, (char) SOM);

    clear_set(continue_tree);
    set_plus_char(continue_tree, (char) BP);
    set_plus_char(continue_tree, (char) NE);
    set_plus_char(continue_tree, (char) TAE);
    set_plus_char(continue_tree, (char) BAE);
    set_plus_char(continue_tree, (char) MAE);


    set_assign(valid_types, origin);

	/* Skip over any comment lines.  All such lines must 
	begin with a non-digit char. */

    while( !(error = !fgets(line, BUFSIZ, fp)) 
	   && 
	   !isdigit(line[0]) )
	line_number++;

    if (error) {
	fprintf(stderr, 
	"read_rd_neuron: error reading %s at line %d\n", 
	filename, line_number);
    	return(error);
    }
    			/* main reading loop: one line per iteration */

    while ( !feof(fp) 
	    &&
	    !ferror(fp) 
	    && 
	    strncmp(line, end_of_file, strlen(end_of_file)) ) {

	line_number++;

			      /* make sure that line ends in a space */
	*(strchr(line,'\n')) = ' ';

						 /* parse point type */
	for (type_ptr = point_type_names,
	     point_type = 0;
	     *type_ptr
	     &&
	     strncmp(type_ptr, 
		       line + POINT_TYPE_ADDR, 
			 POINT_TYPE_SIZE);
	     type_ptr   += POINT_TYPE_SIZE,
	     point_type += POINT_TYPE_SIZE);

	if (!in_set(valid_types, point_type)) {
	    fprintf(stderr,
	    "%s: invalid point type |%3.3s| in line %d\n",
	    filename, line + POINT_TYPE_ADDR, line_number);
	    return(TRUE);
	}

					  /* get length and diameter */

	length = SCALE * atof(line + LENGTH_ADDR);
	diam   = SCALE * atof(line + DIAM_ADDR);

					  	 /* get branch label */
	
	if ((label = strchr(line,' '))) {
	    *label = '\0';
	    label = line;
	}

	switch( point_type ) {


	    case SOM: {
		neuron_ptr->soma_diam = diam;
		neuron_ptr->soma_length = length;
		neuron_ptr->first_soma_point =
		neuron_ptr->last_soma_point = point_number;
		set_assign(valid_types, continue_tree);
		break;
	    }


	    case BP: {

		num_tree_points +=2;
		point_number++;

		if ( next_branch_is_rooted_at_soma
		     &&
		     start_new_tree_2D(point_number,
				        neuron_ptr, 
					  &tree_ptr, 
					    &neurite_ptr,
					      diam ) )
		    return(TRUE);

		next_branch_is_rooted_at_soma = FALSE;

		if (append_to_tree_2D(point_number,
				       &tree_ptr, 
				         length,
					   diam,
					     label))
		    return(TRUE);
		push_branch(tree_ptr);
		break;
	    }


	    case NE:
	    case MAE:
	    case TAE:
	    case BAE: {

		num_branches++;
		num_tree_points +=2;
		point_number++;
		
		if ( next_branch_is_rooted_at_soma
		     &&
		     start_new_tree_2D(point_number,
				        neuron_ptr, 
					  &tree_ptr, 
					    &neurite_ptr,
					      diam ) )
		    return(TRUE);

		next_branch_is_rooted_at_soma = FALSE;

		if (append_to_tree_2D(point_number,
				       &tree_ptr,
				         length,
					   diam,
					     label))
		    return(TRUE);

		if( stack_is_empty() )
		    next_branch_is_rooted_at_soma = TRUE;
		else if( pop_branch(&tree_ptr)) 
		    return(TRUE);
		break;
	    }

	}	/* end: switch point_type */

						    /* get next line */
	fgets(line, BUFSIZ, fp);

    }	/* end main reading loop */


    neuron_ptr->num_branches = num_branches;
    neuron_ptr->num_tree_points = num_tree_points;

    calculate_3D_coordinates( neuron_ptr );

    return(error);

}


/*-------------------------------------------------------------------*/
static void calculate_3D_coordinates( neuron_ptr )

	/* Constructs a 2-element soma_3D_list from the cylindrical
	soma length and diameter.  Also fills the x and y fields of
	each tree point as appropriate for a 2D diagram of the 
	neuron.  */

    NEURON    * neuron_ptr;

{
				       /*----- functions called -----*/
    void calculate_x_y();

				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    TREE_POINT * tree_ptr;
    XYZD       * soma_3D_ptr;

    double	root_x,
		root_y;
				       /*----- start function -------*/

    if (reallocate( (char **) &(neuron_ptr->soma_3D_list),
		    2 * sizeof(XYZD),
		    "soma 3D list" ))
	exit(TRUE);

    bzero( (char *) neuron_ptr->soma_3D_list,
	   2 * sizeof(XYZD) );

    neuron_ptr->num_soma_3D_points = 2;

    soma_3D_ptr = neuron_ptr->soma_3D_list;

    soma_3D_ptr[0].y = 
    soma_3D_ptr[1].y = neuron_ptr->soma_diam/2.0;

    root_y =
    soma_3D_ptr[0].diam = 
    soma_3D_ptr[1].diam = neuron_ptr->soma_diam;

    root_x = 
    soma_3D_ptr[1].x = neuron_ptr->soma_length;

    for( tree_ptr = neuron_ptr->neurites;
	 tree_ptr && tree_ptr->next;
	 tree_ptr = tree_ptr->branch ) {

	calculate_x_y(tree_ptr->next, root_x, &root_y);

    }

}



/*-------------------------------------------------------------------*/
static void calculate_x_y(root_ptr, root_x, root_y_ptr)

	/* Calculates the x and y coordinate values for all tree
	points in the branch rooted at root_ptr->previous.  
	Recursively does the same for all higher order branches 
	connected to this one.  On entry root_x is the x coordinate
	of the leftmost (most proximal) TREE_POINT in the branch,
	and *root_y_ptr is the y coordinate of the branch just below
	this one plus half of the maximal diameter of that branch. */

    TREE_POINT     * root_ptr;
    double	     root_x,
		   * root_y_ptr;

{
				       /*----- functions called -----*/
				       /*----- extern variables -----*/
				       /*----- local  variables -----*/
    double	max_diam,
		y;

    TREE_POINT *tree_ptr;
				       /*----- start function -------*/

    max_diam = 0.0;

    for (tree_ptr = root_ptr->previous;
	 tree_ptr->next;
	 tree_ptr = tree_ptr->next ) {

	if (max_diam < tree_ptr->diam)
	    max_diam = tree_ptr->diam;
    }

    y = *root_y_ptr += BRANCH_SPACING * max_diam/2.0;

    					       /* fill x coordinates */
    root_ptr->previous->x = root_x;

    for( tree_ptr = root_ptr;
	 tree_ptr;
	 tree_ptr = tree_ptr->next ) {

	tree_ptr->x = tree_ptr->previous->x + tree_ptr->length;
    }
				       /* go to distal end of branch */
    for( tree_ptr = root_ptr;
	 tree_ptr && tree_ptr->next;
	 tree_ptr = tree_ptr->next );

			       /* do connecting branches recursively */
    for ( ;
	  (tree_ptr->next) != root_ptr
	  &&
	  (tree_ptr->branch) != root_ptr;
	  tree_ptr = tree_ptr->previous )

	if (tree_ptr->branch)
	    calculate_x_y(tree_ptr->branch, tree_ptr->x, root_y_ptr);

    					       /* fill y coordinates */
    root_ptr->previous->y = y;

    for( tree_ptr = root_ptr;
	 tree_ptr;
	 tree_ptr = tree_ptr->next ) {

	tree_ptr->y = y;
    }
}				       /*----- end function ---------*/

/*-------------------------------------------------------------------*/
static int start_new_tree_2D( point_number, 
			      neuron_ptr, 
			      tree_2ptr, 
			      neurite_2ptr, 
			      diam )

	/* Starts a new tree of neurites, rooted at the soma of 
	*neuron_ptr, by allocating the first TREE_POINT.  Memory for 
        this first point is allocated either at neuron_ptr->neurites, 
        if this is NULL on entry, or at *neurite_2ptr->branch.  Returns 
        pointers to the newly allocated point in both *tree_2ptr and 
        *neurite_2ptr.  Uses the remaining arguments to fill the other 
        fields of the new TREE_POINT.  The length is 0 for all 
	TREE_POINTs rooted at the soma.  In contrast to the Eutectic
	syntax, the Douglas 2D syntax does not include a special point
	for the origin of a primary neurite; therefore the TREE_POINT
	created by this routine has no corresponding line in the source
	file.  To indicate this fact, the point number assigned to 
	this TREE_POINT is the negative of point_number.  Returns TRUE
	if error; FALSE otherwise. */

    NEURON      * neuron_ptr;
    TREE_POINT ** tree_2ptr,
	       ** neurite_2ptr;
    int		  point_number;
    double	  diam;

{
				       /*----- functions called -----*/

				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int		  error;
    TREE_POINT	* ptr;
				       /*----- start function -------*/

    if (error = allocate_bytes( (char **) &ptr,
				      sizeof(TREE_POINT),
					"new tree point" ))
	return(error);

    if (neuron_ptr->neurites)
	(*neurite_2ptr)->branch = ptr;
    else 
	neuron_ptr->neurites = ptr;

    *tree_2ptr = *neurite_2ptr = ptr;
    memset( (char *) ptr, '\0', sizeof(TREE_POINT) );
    ptr->diam = diam;
    ptr->point_number = -point_number;
    error = strsave(&(ptr->point_label), "");

    return(error);
}				       /*----- end function ---------*/

/*-------------------------------------------------------------------*/
static int append_to_tree_2D( point_number, 
			      tree_2ptr, 
			      length, 
			      diam, 
			      label)

	/* Appends a new TREE_POINT to an existing tree of neurites.
	Memory for this new point is allocated either at 
        (*tree_2ptr)->next, if this is NULL on entry, or at 
        (*tree_2ptr)->branch.  Returns a pointer to the newly allocated 
        point in *tree_2ptr.   Uses the remaining arguments to fill the 
        other fields of the new TREE_POINT.  In contrast to the 
	Eutectic syntax, the Douglas 2D syntax implicitly requires
	discontinuous changes in diameter.  To represent such 
	discontinuities, this routine inserts an extra point with
	length=0 to store the new diameter coincident with the previous
	(more proximal) point.  This point is given a negative 
	point_number to indicate that it has no corresponding line in 
	the source file. Returns TRUE if error; FALSE otherwise. */

    TREE_POINT ** tree_2ptr;
    char	* label;
    int 	  point_number;
    double	  length,
		  diam;

{
				       /*----- functions called -----*/
				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int		error;
    TREE_POINT *ptr;
				       /*----- start function -------*/

    if (error = allocate_bytes( (char **) &ptr,
				  sizeof(TREE_POINT),
				    "new tree point" ))
	return(error);

    memset( (char *) ptr, '\0', sizeof(TREE_POINT) );
    ptr->previous = *tree_2ptr;
    ptr->diam = diam;
    if (label)
        error = strsave(&(ptr->point_label), label);
    else
        error = strsave(&(ptr->point_label), "");

    if ((*tree_2ptr)->next)
	(*tree_2ptr)->branch = ptr;
    else
	(*tree_2ptr)->next = ptr;

    if ((*tree_2ptr)->point_number > 0) {
    	ptr->point_number = -point_number;
	error= append_to_tree_2D( point_number, 
				  &ptr, 
				  length, 
				  diam, 
				  label);
    }
    else {
    	ptr->length = length;
    	ptr->point_number = point_number;
    }

    *tree_2ptr = ptr;

    return(error);
}				       /*----- end function ---------*/


