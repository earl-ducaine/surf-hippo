	/* %W%  %G% */

	/*-------------------------------------------------------------
	|							      |
	|	PROGRAM:  ntscable                                    |
	|							      |
	|	MODULE:   %M%                                         |
	|							      |
	|	MACHINE:  Sun 3/60                                    |
	|							      |
	|	STARTED:  11-DEC-90        BY:  J.C. Wathey           |
	|							      |
	|	REVISED:  %G%         BY:  JCW                   |
	|							      |
	|	STATUS:      incomplete or untested		      |
	|                    compiles; partly tested		      |
	|                 -> runs; revisions in progress	      |
	|                    runs; stable version		      |
	|							      |
	|       CONTAINS: routine read_nevin() and related            |
	|                 private routines                            |
	|       COMPILE:                                              |
	|                                                             |
	|       (use makefile)                                        |
	|                                                             |
	-------------------------------------------------------------*/

/*--------------------------------------- HEADER FILES --------------*/
#include "tf.h"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <ctype.h>
#include <errno.h>
#include "sets.h"
#include "ntscable.h"		       /* global defs & declarations */


/*-------------------------------------------------------------------*/
int read_nevin(fp, neuron_ptr, line_number)

	/* Reads morphological description of a neuron from an ASCII
	file generated by Rocky Nevin's DIG program and stores this
	description in dynamic memory under the appropriate fields of
	*neuron_ptr.  Gives messages and returns TRUE if error; 
	otherwise returns FALSE. */

    FILE      * fp; 
    NEURON    * neuron_ptr; 
    int		line_number;

{
				       /*----- functions called -----*/
    double	distance();
    void	append_soma_3D_point();
				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int 	error,
		next_branch_is_rooted_at_soma = TRUE,
		point_number = 0,
		num_tree_points = 0,
		num_branches = 0,
		reading_soma_points = FALSE; 

    char      * filename;

    char	line[BUFSIZ],
		point_type;

    double	soma_x,
		soma_y,
		soma_z,
		x, y, z, diam;

    TREE_POINT *tree_ptr    = (TREE_POINT *) NULL,
	       *neurite_ptr = (TREE_POINT *) NULL;

    SET		valid_types;
	
				       /*----- start function -------*/

    neuron_ptr->source = NEVIN;
    neuron_ptr->average_outline_z_coords = FALSE;

    filename = neuron_ptr->input_filename;
    						  /* initialize sets */
    set_assign(valid_types, str_to_set("SCBTFcf"));

	/* Skip over leading comment and header lines in the file.
	All such lines must begin with a non-digit char. */

    while( !(error = !fgets(line, BUFSIZ, fp)) 
	   && 
	   !(isdigit(*line)) )
	line_number++;

    			/* main reading loop: one line per iteration */

    while ( !error && !feof(fp) && !(error=ferror(fp)) ) {

	line_number++;
						 /* parse line */
	if (6 != sscanf(line, "%d \t %c %lf %lf %lf %lf",
			&point_number,
			&point_type,
			&x,
			&y,
			&z,
			&diam )) {
	    fprintf(stderr, 
	    "read_nevin: syntax error in %s at line %d:\n%s\n", 
	    filename, line_number, line);
    	    return(TRUE);
	}

	if (!in_set(valid_types, point_type)) {
	    fprintf(stderr,
	    "%s: invalid point type '%c' in line %d\n",
	    filename, point_type, line_number);
	    return(TRUE);
	}

	switch( point_type ) {

	    case 'B': {
		if (reading_soma_points) {
		    neuron_ptr->last_soma_point = point_number;
		    append_soma_3D_point( neuron_ptr, x, y, z, diam);
		}
		else {
		    num_tree_points++;

		    if ( next_branch_is_rooted_at_soma ) {
		        next_branch_is_rooted_at_soma = FALSE;
			if (start_new_tree(neuron_ptr, 
					    point_number,
					      &tree_ptr, 
						&neurite_ptr,
						  x,y,z,diam ))
			    return(TRUE);
		    }
		    else if ( append_to_tree(point_number,
					       &tree_ptr, x,y,z,diam ))
			return(TRUE);
		    push_branch(tree_ptr);
		}
		break;
	    }


	    case 'S': {
		if ( !(neuron_ptr->num_soma_3D_points) ) {
		    reading_soma_points = TRUE;
		    neuron_ptr->first_soma_point= point_number;
		}
		neuron_ptr->last_soma_point = point_number;
		append_soma_3D_point( neuron_ptr, x, y, z, diam);
		break;
	    }
		
	    case 'C': {
		reading_soma_points = FALSE;
		num_tree_points++;
		if ( next_branch_is_rooted_at_soma ) {
		    next_branch_is_rooted_at_soma = FALSE;
		    if (start_new_tree(neuron_ptr, 
					point_number,
					  &tree_ptr, 
					    &neurite_ptr,
					      x,y,z,diam ))
			return(TRUE);
		}
		else if ( append_to_tree(point_number,
					 &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		break;
	    }

	    case 'T': {
		if (reading_soma_points) {
		    reading_soma_points = FALSE;
		    neuron_ptr->last_soma_point = point_number;
		    append_soma_3D_point( neuron_ptr, x, y, z, diam);
		}
		else {
		    num_branches++;
		    num_tree_points++;
		    if ( append_to_tree(point_number,
					&tree_ptr, x,y,z,diam ))
			return(TRUE);
		    if( stack_is_empty() )
			next_branch_is_rooted_at_soma = TRUE;
		    else if (pop_branch(&tree_ptr))
			return(TRUE);
		}
		break;
	    }
					/* ignore fiducial points */
	    case 'c':
	    case 'f':
	    case 'F':
		break;


	}	/* end: switch point_type */

						 /* get next line */
	fgets(line, BUFSIZ, fp);

    }	/* end main reading loop */

    neuron_ptr->num_branches = num_branches;
    neuron_ptr->num_tree_points = num_tree_points;

    if (error) {
	fprintf(stderr, 
	"read_nevin: error reading %s at line %d\n", 
	filename, line_number);
    }

    return(error);

}



