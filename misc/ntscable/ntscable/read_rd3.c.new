	/* %W%  %G% */

	/*-------------------------------------------------------------
	|							      |
	|	PROGRAM:  ntscable                                    |
	|							      |
	|	MODULE:   %M%                                         |
	|							      |
	|	MACHINE:  Sun 3/60                                    |
	|							      |
	|	STARTED:  18-AUG-91        BY:  J.C. Wathey           |
	|							      |
	|	REVISED:  %G%         BY:  JCW                   |
	|							      |
	|	STATUS:      incomplete or untested		      |
	|                    compiles; partly tested		      |
	|                 -> runs; revisions in progress	      |
	|                    runs; stable version		      |
	|							      |
	|       CONTAINS: routine read_douglas_3d() and related       |
	|		  private routines                            |
	|                                                             |
	|       COMPILE:                                              |
	|                                                             |
	|       (use makefile)                                        |
	|                                                             |
	-------------------------------------------------------------*/

/*--------------------------------------- HEADER FILES --------------*/
#include "tf.h"
#include <stdio.h>
#include <math.h>
#include <sys/types.h>
#include <ctype.h>
#include <errno.h>
#include "sets.h"
#include "ntscable.h"		       /* global defs & declarations */

	/* definitions related to the ASCII file format used by
	Rodney Douglas' neuron digitizing system; 3D syntax */

	      /* These serve both as tokens for the point types and as
	      offsets for pointing to the corresponding substrings of 
	      point_type_names  (declared below). */

#define	MTO	0
#define	CP	3
#define	BP	6
#define	NE	9
#define	MAE	12
#define	TAE	15
#define	BAE	18
#define	SCP	21

			    /* field addresses within the text line */
#define POINT_TYPE_ADDR	0
#define POINT_TYPE_SIZE	3
#define X_ADDR		3
#define Y_ADDR		16
#define Z_ADDR		27
#define DIAM_ADDR	38

static char	point_type_names[] = "mtodcpbp ne maetaebaescp";

/*-------------------------------------------------------------------*/
int read_douglas_3d(fp, neuron_ptr, line_number)

	/* Reads morphological description of a neuron from an ASCII
	file generated by Rodney Douglas' neuron digitizing system 
	(3D syntax) and stores this description in dynamic memory 
	under the appropriate fields of *neuron_ptr.  The main 
	ways in which Douglas 3d syntax differs from Eutectic is
	the absence of point type numbers and the use of MTO and 
	MAE in place of SOS and SOE, respectively.  This routine
	uses the line number as the point number.  Gives messages 
	and returns TRUE if error; otherwise returns FALSE. */

    FILE      * fp; 
    NEURON    * neuron_ptr; 
    int		line_number;

{
				       /*----- functions called -----*/
    void	append_soma_outline_point(),
		push_branch();
    int		stack_is_empty(),
		pop_branch();

				       /*----- extern variables -----*/

				       /*----- local  variables -----*/
    int 	point_type,
		num_soma_outline_points = 0,
		num_tree_points = 0,
		num_branches = 0, 
		last_point_was_MTO = FALSE,
		reading_soma_outline = FALSE,
		first_soma_point = 0;

    char      * filename;

    char	line[BUFSIZ],
	      * type_ptr;

    double	x, y, z, diam,
		area,
		x_prev,
		y_prev,
		x_start,
		y_start;

    SOMA_POINT *soma_outline = (SOMA_POINT *) NULL;

    TREE_POINT *tree_ptr,
	       *neurite_ptr;

    SET		origin,
		continue_all,
		continue_tree,
		continue_soma,
		valid_types;
	
				       /*----- start function -------*/

    neuron_ptr->source = DOUGLAS_3D;

    filename = neuron_ptr->input_filename;
    						  /* initialize sets */
    clear_set(origin);
    set_plus_char(origin, (char) MTO);

    clear_set(continue_tree);
    set_plus_char(continue_tree, (char) BP);
    set_plus_char(continue_tree, (char) CP);
    set_plus_char(continue_tree, (char) NE);
    set_plus_char(continue_tree, (char) TAE);
    set_plus_char(continue_tree, (char) BAE);
    set_plus_char(continue_tree, (char) MAE);

    clear_set(continue_soma);
    set_plus_char(continue_soma, (char) SCP);
    set_plus_char(continue_soma, (char) MAE);

    set_assign(valid_types, origin);
    set_assign(continue_all, continue_tree);
    set_plus(continue_all, continue_soma);

    						  /* read first line */
    fgets(line, BUFSIZ, fp);

    			/* main reading loop: one line per iteration */

    while ( !feof(fp) && !ferror(fp) ) {

	line_number++;

						 /* parse point type */
	for (type_ptr = point_type_names,
	     point_type = 0;

	     *type_ptr
	     &&
	     strncmp(type_ptr, 
		       line + POINT_TYPE_ADDR, 
			 POINT_TYPE_SIZE);

	     type_ptr   += POINT_TYPE_SIZE,
	     point_type += POINT_TYPE_SIZE);

	if (!in_set(valid_types, point_type)) {
	    fprintf(stderr,
	    "%s: rd3  invalid point type %3.3s in line %d\n",
	    filename, line + POINT_TYPE_ADDR, line_number);
	    return(TRUE);
	}

	if (last_point_was_MTO) {
 	    last_point_was_MTO = FALSE;
	    if (in_set(continue_tree, point_type)) {
		num_tree_points++;
		if (start_new_tree(neuron_ptr, 
				    line_number-1,
				      &tree_ptr, 
			 	       &neurite_ptr,
			  	        x,y,z,diam ))
		    return(TRUE);
        	set_assign( valid_types, continue_tree );
	    }
	    else {
		x_prev = x_start = x;
		y_prev = y_start = y;
		area = 0;
		num_soma_outline_points++;
		first_soma_point = line_number-1;
		append_soma_outline_point( &soma_outline, 
					   line_number-1,
					   x, y, z);
		set_assign(valid_types, continue_soma);
		reading_soma_outline = TRUE;
	    }
	}
				     /* get coordinates and diameter */

	x =    atof(line + X_ADDR)/10.0;
	y =    atof(line + Y_ADDR)/10.0;
	z =    atof(line + Z_ADDR)/10.0;
	diam = atof(line + DIAM_ADDR)/10.0;
	switch( point_type ) {

	    case MTO: {
		last_point_was_MTO = TRUE;
        	set_assign( valid_types, continue_all );
		break;
	    }

	    case BP: {
		num_tree_points++;
		if (append_to_tree(line_number,
				   &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		push_branch(tree_ptr);
		break;
	    }

	    case CP: {
		num_tree_points++;
		if (append_to_tree(line_number,
				   &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		break;
	    }

	    case MAE:
		if (reading_soma_outline) {
		    reading_soma_outline = FALSE;
		    area += (x_prev * y)  - (x * y_prev)
		          + (x * y_start) - (x_start * y);
		    area  /= 2;
		    area = fabs(area);
		    num_soma_outline_points++;
		    append_soma_outline_point( &soma_outline, 
					       line_number,
					       x, y, z);
		    if ( neuron_ptr->soma_diam 
		         < 
		         (diam = 2 * sqrt(area/M_PI)) ) {
		        neuron_ptr->soma_outline_diam = diam;
		        neuron_ptr->num_soma_outline_points
		        	  = num_soma_outline_points;
		        neuron_ptr->first_soma_point 
		        	  = first_soma_point;
		        neuron_ptr->last_soma_point 
				  = line_number;
			free_soma_outline(&(neuron_ptr->soma_outline));
			neuron_ptr->soma_outline = soma_outline;
			soma_outline = (SOMA_POINT *) NULL;
		    }
		    else {
			free_soma_outline(&soma_outline);
		    }
		    num_soma_outline_points = 0;
		    set_assign(valid_types, origin);
		    break;
		}
	    case NE:
	    case TAE:
	    case BAE: {
		num_branches++;
		num_tree_points++;
		if (append_to_tree(line_number,
				   &tree_ptr, x,y,z,diam ))
		    return(TRUE);
		if( stack_is_empty() )
		    set_assign(valid_types, origin);
		else if (pop_branch(&tree_ptr))
		    return(TRUE);
		break;
	    }

	    case SCP: {
		area += (x_prev * y) - (x * y_prev);
		x_prev = x;
		y_prev = y;
		num_soma_outline_points++;
		append_soma_outline_point( &soma_outline, 
					   line_number,
					   x, y, z);
		break;
	    }

	}	/* end: switch point_type */

						    /* get next line */
	fgets(line, BUFSIZ, fp);

    }	/* end main reading loop */

    neuron_ptr->num_branches = num_branches;
    neuron_ptr->num_tree_points = num_tree_points;

    return(FALSE);

}



